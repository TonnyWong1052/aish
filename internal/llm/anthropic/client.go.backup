package anthropic

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
	"regexp"
	"strings"
	"text/template"
	"time"

	"github.com/TonnyWong1052/aish/internal/config"
	"github.com/TonnyWong1052/aish/internal/llm"
	"github.com/TonnyWong1052/aish/internal/prompt"
)

// Anthropic API structures
type Message struct {
	Role    string `json:"role"`
	Content string `json:"content"`
}

type MessagesRequest struct {
	Model      string    `json:"model"`
	Messages   []Message `json:"messages"`
	MaxTokens  int       `json:"max_tokens"`
	Temperature float64  `json:"temperature,omitempty"`
}

type MessagesResponse struct {
	ID      string `json:"id"`
	Type    string `json:"type"`
	Role    string `json:"role"`
	Content []struct {
		Type string `json:"type"`
		Text string `json:"text"`
	} `json:"content"`
	Model        string      `json:"model"`
	StopReason   string      `json:"stop_reason"`
	StopSequence interface{} `json:"stop_sequence"`
	Usage        struct {
		InputTokens  int `json:"input_tokens"`
		OutputTokens int `json:"output_tokens"`
	} `json:"usage"`
	Error *struct {
		Type    string `json:"type"`
		Message string `json:"message"`
	} `json:"error,omitempty"`
}

// ClaudeProvider implements the llm.Provider interface for Anthropic Claude.
type ClaudeProvider struct {
	cfg    config.ProviderConfig
	pm     *prompt.Manager
	client *http.Client
}

// NewProvider creates a new ClaudeProvider.
func NewProvider(cfg config.ProviderConfig, pm *prompt.Manager) (llm.Provider, error) {
	client := &http.Client{
		Timeout: 90 * time.Second,
	}

	return &ClaudeProvider{
		cfg:    cfg,
		pm:     pm,
		client: client,
	}, nil
}

func init() {
	llm.RegisterProvider("claude", NewProvider)
}

// GetSuggestion implements the llm.Provider interface.
func (p *ClaudeProvider) GetSuggestion(ctx context.Context, capturedContext llm.CapturedContext, lang string) (*llm.Suggestion, error) {
	// Get the prompt template
	promptTemplate, err := p.pm.GetPrompt("get_suggestion", mapLanguage(lang))
	if err != nil {
		return nil, fmt.Errorf("failed to get prompt template: %w", err)
	}

	// Execute template with context data
	data := struct {
		Command  string
		Stdout   string
		Stderr   string
		ExitCode int
	}{
		Command:  capturedContext.Command,
		Stdout:   capturedContext.Stdout,
		Stderr:   capturedContext.Stderr,
		ExitCode: capturedContext.ExitCode,
	}

	var tpl bytes.Buffer
	t := template.Must(template.New("prompt").Parse(promptTemplate))
	if err := t.Execute(&tpl, data); err != nil {
		return nil, fmt.Errorf("failed to execute template: %w", err)
	}

	// Make API request
	response, err := p.messagesAPI(ctx, tpl.String())
	if err != nil {
		return nil, fmt.Errorf("Claude API request failed: %w", err)
	}

	// Prefer JSON output
	cleaned := stripCodeFences(response)
	var obj struct {
		Explanation      string `json:"explanation"`
		Command          string `json:"command"`
		CorrectedCommand string `json:"corrected_command"`
		CorrectedCamel   string `json:"correctedCommand"`
	}
	if err := json.Unmarshal([]byte(cleaned), &obj); err == nil {
		cmd := obj.Command
		if cmd == "" {
			cmd = obj.CorrectedCommand
		}
		if cmd == "" {
			cmd = obj.CorrectedCamel
		}
		if strings.TrimSpace(cmd) != "" && strings.TrimSpace(obj.Explanation) != "" {
			return &llm.Suggestion{Explanation: strings.TrimSpace(obj.Explanation), CorrectedCommand: strings.TrimSpace(cmd)}, nil
		}
	}

	// Fallback: heuristic parsing
	return p.parseSuggestionResponse(response)
}

// GetEnhancedSuggestion implements the llm.Provider interface with enhanced context.
func (p *ClaudeProvider) GetEnhancedSuggestion(ctx context.Context, enhancedCtx llm.EnhancedCapturedContext, lang string) (*llm.Suggestion, error) {
	// Get the enhanced prompt template
	promptTemplate, err := p.pm.GetPrompt("get_enhanced_suggestion", mapLanguage(lang))
	if err != nil {
		// Fall back to regular suggestion if enhanced template doesn't exist
		return p.GetSuggestion(ctx, enhancedCtx.CapturedContext, lang)
	}

	// Create template functions
	funcMap := template.FuncMap{
		"add": func(a, b int) int {
			return a + b
		},
	}

	// Execute template with enhanced context data
	var tpl bytes.Buffer
	t, err := template.New("prompt").Funcs(funcMap).Parse(promptTemplate)
	if err != nil {
		return nil, fmt.Errorf("failed to parse enhanced template: %w", err)
	}

	if err := t.Execute(&tpl, enhancedCtx); err != nil {
		return nil, fmt.Errorf("failed to execute enhanced template: %w", err)
	}

	// Make API request
	response, err := p.messagesAPI(ctx, tpl.String())
	if err != nil {
		return nil, fmt.Errorf("Claude API request failed for enhanced suggestion: %w", err)
	}

	// Prefer JSON output (same parsing logic as regular GetSuggestion)
	cleaned := stripCodeFences(response)
	var obj struct {
		Explanation      string `json:"explanation"`
		Command          string `json:"command"`
		CorrectedCommand string `json:"corrected_command"`
		CorrectedCamel   string `json:"correctedCommand"`
	}
	if err := json.Unmarshal([]byte(cleaned), &obj); err == nil {
		cmd := obj.Command
		if cmd == "" {
			cmd = obj.CorrectedCommand
		}
		if cmd == "" {
			cmd = obj.CorrectedCamel
		}
		if strings.TrimSpace(cmd) != "" && strings.TrimSpace(obj.Explanation) != "" {
			return &llm.Suggestion{Explanation: strings.TrimSpace(obj.Explanation), CorrectedCommand: strings.TrimSpace(cmd)}, nil
		}
	}

	// Fallback: heuristic parsing
	return p.parseSuggestionResponse(response)
}

// GenerateCommand implements the llm.Provider interface.
func (p *ClaudeProvider) GenerateCommand(ctx context.Context, promptText string, lang string) (string, error) {
	// Get the prompt template
	promptTemplate, err := p.pm.GetPrompt("generate_command", mapLanguage(lang))
	if err != nil {
		return "", fmt.Errorf("failed to get prompt template: %w", err)
	}

	// Execute template with prompt data
	data := struct{ Prompt string }{Prompt: promptText}
	var tpl bytes.Buffer
	t := template.Must(template.New("prompt").Parse(promptTemplate))
	if err := t.Execute(&tpl, data); err != nil {
		return "", fmt.Errorf("failed to execute template: %w", err)
	}

	// Make API request
	response, err := p.messagesAPI(ctx, tpl.String())
	if err != nil {
		return "", fmt.Errorf("Claude API request failed: %w", err)
	}

	// Prefer JSON output
	cleaned := stripCodeFences(response)
	var obj struct {
		Command string `json:"command"`
	}
	if err := json.Unmarshal([]byte(cleaned), &obj); err == nil && strings.TrimSpace(obj.Command) != "" {
		return strings.TrimSpace(obj.Command), nil
	}

	// Fallback: extract plausible shell command
	if cmd := extractPlausibleCommand(response); cmd != "" {
		return cmd, nil
	}
	return "", fmt.Errorf("no plausible command found in provider response")
}

// VerifyConnection implements the llm.Provider interface.
func (p *ClaudeProvider) VerifyConnection(ctx context.Context) ([]string, error) {
	if p.cfg.APIKey == "" {
		return nil, errors.New("API key is missing for Claude")
	}

	// Try a simple test request
	testReq := MessagesRequest{
		Model: p.cfg.Model,
		Messages: []Message{
			{Role: "user", Content: "Hello"},
		},
		MaxTokens: 10,
	}

	jsonBody, err := json.Marshal(testReq)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal test request: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "POST", p.cfg.APIEndpoint+"/messages", bytes.NewReader(jsonBody))
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	req.Header.Set("x-api-key", p.cfg.APIKey)
	req.Header.Set("anthropic-version", "2023-06-01")
	req.Header.Set("content-type", "application/json")

	resp, err := p.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("request failed: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != 200 {
		body, _ := io.ReadAll(resp.Body)
		return nil, fmt.Errorf("API returned status %d: %s", resp.StatusCode, string(body))
	}

	// Return available Claude models
	return []string{
		"claude-3-5-sonnet-20241022",
		"claude-3-5-haiku-20241022",
		"claude-3-opus-20240229",
	}, nil
}

// messagesAPI makes a request to Claude Messages API
func (p *ClaudeProvider) messagesAPI(ctx context.Context, message string) (string, error) {
	reqBody := MessagesRequest{
		Model: p.cfg.Model,
		Messages: []Message{
			{Role: "user", Content: message},
		},
		MaxTokens:   1024,
		Temperature: 0.1,
	}

	jsonBody, err := json.Marshal(reqBody)
	if err != nil {
		return "", fmt.Errorf("failed to marshal request: %w", err)
	}

	// Retry logic for transient errors
	var resp *http.Response
	var doErr error
	for attempt := 0; attempt < 3; attempt++ {
		req, err := http.NewRequestWithContext(ctx, "POST", p.cfg.APIEndpoint+"/messages", bytes.NewReader(jsonBody))
		if err != nil {
			return "", fmt.Errorf("failed to create request: %w", err)
		}

		req.Header.Set("x-api-key", p.cfg.APIKey)
		req.Header.Set("anthropic-version", "2023-06-01")
		req.Header.Set("content-type", "application/json")

		resp, doErr = p.client.Do(req)
		if doErr != nil {
			time.Sleep(time.Duration(250*(attempt+1)) * time.Millisecond)
			continue
		}

		// Retry on common transient errors
		if resp.StatusCode == http.StatusBadGateway || resp.StatusCode == http.StatusServiceUnavailable || resp.StatusCode == http.StatusGatewayTimeout {
			io.Copy(io.Discard, resp.Body)
			resp.Body.Close()
			time.Sleep(time.Duration(250*(attempt+1)) * time.Millisecond)
			continue
		}
		break
	}
	if doErr != nil {
		return "", fmt.Errorf("request failed: %w", doErr)
	}
	defer resp.Body.Close()

	body, readErr := io.ReadAll(resp.Body)
	if readErr != nil {
		return "", fmt.Errorf("failed to read response: %w", readErr)
	}

	// Parse response
	var claudeResp MessagesResponse
	if err := json.Unmarshal(body, &claudeResp); err != nil {
		return "", fmt.Errorf("failed to decode response: %w", err)
	}

	if claudeResp.Error != nil {
		return "", fmt.Errorf("API error: %s", claudeResp.Error.Message)
	}

	if len(claudeResp.Content) == 0 {
		return "", errors.New("no response content returned")
	}

	return claudeResp.Content[0].Text, nil
}

// parseSuggestionResponse parses the Claude response to extract explanation and command
func (p *ClaudeProvider) parseSuggestionResponse(response string) (*llm.Suggestion, error) {
	response = strings.TrimSpace(response)

	var explanation string
	var correctedCommand string

	lines := strings.Split(response, "\n")
	explanationFound := false
	commandFound := false

	for _, line := range lines {
		line = strings.TrimSpace(line)
		if line == "" {
			continue
		}

		// Look for explanation markers
		if strings.Contains(strings.ToLower(line), "explanation") && !explanationFound {
			explanationFound = true
			if idx := strings.Index(strings.ToLower(line), "explanation"); idx != -1 {
				afterExplanation := strings.TrimSpace(line[idx+len("explanation"):])
				afterExplanation = strings.TrimLeft(afterExplanation, ":")
				afterExplanation = strings.TrimSpace(afterExplanation)
				if afterExplanation != "" {
					explanation = afterExplanation
				}
			}
			continue
		}

		// Look for command markers
		if (strings.Contains(strings.ToLower(line), "corrected") ||
			strings.Contains(strings.ToLower(line), "command")) && !commandFound {
			commandFound = true
			parts := strings.Split(line, ":")
			if len(parts) > 1 {
				cmd := strings.TrimSpace(parts[len(parts)-1])
				cmd = strings.Trim(cmd, "`")
				if cmd != "" && !strings.Contains(strings.ToLower(cmd), "command") {
					correctedCommand = cmd
				}
			}
			continue
		}

		if explanationFound && explanation == "" && !strings.Contains(strings.ToLower(line), "command") {
			explanation = line
			explanationFound = false
			continue
		}

		if commandFound && correctedCommand == "" {
			cmd := strings.Trim(line, "`")
			if cmd != "" {
				correctedCommand = cmd
			}
			commandFound = false
			continue
		}
	}

	// If we didn't find structured response, try to extract from the full response
	if explanation == "" || correctedCommand == "" {
		if strings.Contains(response, "Explanation:") && strings.Contains(response, "Corrected Command:") {
			parts := strings.Split(response, "Corrected Command:")
			if len(parts) >= 2 {
				correctedCommand = strings.TrimSpace(strings.Trim(parts[1], "`"))
				explanationPart := strings.Split(parts[0], "Explanation:")
				if len(explanationPart) >= 2 {
					explanation = strings.TrimSpace(explanationPart[1])
				}
			}
		} else {
			explanation = response
			if start := strings.Index(response, "`"); start != -1 {
				if end := strings.Index(response[start+1:], "`"); end != -1 {
					correctedCommand = response[start+1 : start+1+end]
				}
			}
		}
	}

	// Final fallbacks
	if explanation == "" {
		explanation = "Please check command syntax and parameters."
	}
	if correctedCommand == "" {
		correctedCommand = "echo 'Unable to auto-correct command, please check manually'"
	}

	return &llm.Suggestion{
		Explanation:      explanation,
		CorrectedCommand: correctedCommand,
	}, nil
}

// Helper functions (shared with OpenAI provider pattern)

func mapLanguage(lang string) string {
	switch strings.ToLower(lang) {
	case "chinese", "zh", "zh-TW", "zh-CN":
		return "zh-TW"
	case "english", "en":
		return "en"
	default:
		return "en"
	}
}

func stripCodeFences(s string) string {
	s = strings.TrimSpace(s)
	if strings.HasPrefix(s, "```") {
		s = strings.TrimPrefix(s, "```")
		s = strings.TrimSpace(s)
		if strings.HasPrefix(strings.ToLower(s), "json") {
			s = strings.TrimSpace(s[4:])
		}
		if idx := strings.LastIndex(s, "```"); idx != -1 {
			s = s[:idx]
		}
	}
	return strings.TrimSpace(strings.Trim(s, "`"))
}

func extractPlausibleCommand(text string) string {
	s := strings.TrimSpace(text)
	if s == "" {
		return ""
	}
	// Reject obvious prose answers
	lower := strings.ToLower(s)
	banned := []string{"i am", "i'm", "i cannot", "i can't", "large language model", "sorry", "cannot answer", "i don't"}
	for _, b := range banned {
		if strings.Contains(lower, b) {
			return ""
		}
	}
	// Prefer fenced code blocks
	if i := strings.LastIndex(s, "```"); i != -1 {
		start := strings.LastIndex(s[:i], "```")
		if start != -1 && start < i {
			block := s[start+3 : i]
			for _, line := range strings.Split(block, "\n") {
				line = strings.TrimSpace(line)
				if line == "" || strings.HasPrefix(line, "#") {
					continue
				}
				if plausibleCommand(line) {
					return line
				}
			}
		}
	}
	// Scan lines
	for _, line := range strings.Split(s, "\n") {
		line = strings.TrimSpace(line)
		if line == "" || strings.HasPrefix(line, "#") {
			continue
		}
		if plausibleCommand(line) {
			return line
		}
	}
	return ""
}

var cmdStartRe = regexp.MustCompile(`^(?i)\s*(sudo\s+)?([a-z][a-z0-9._-]*|\.|\.\.|\./|/|~)(\s|$)`)

func plausibleCommand(line string) bool {
	l := strings.TrimSpace(line)
	if l == "" {
		return false
	}
	if strings.HasPrefix(l, "bash") {
		l = strings.TrimSpace(strings.TrimPrefix(l, "bash"))
		if l == "" {
			return false
		}
	}
	if !cmdStartRe.MatchString(l) {
		return false
	}
	if strings.HasSuffix(l, ".") && !strings.ContainsAny(l, "/-'_\"$&|><") {
		return false
	}
	return true
}
